# -*- coding: utf-8 -*-
"""ED - Algoritmos de Ordenação de Dados

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VLbaLSGHLOG721X_XuWbZHTU6N2ofpH_

<h1>CST Sistemas para Internet / CST Redes de Computadores</h1>
<h1><b>Estrutura de Dados</b></h1>
<h2>Professor: Alex Sandro</h2>
<h2>Algoritmos de Ordenação de Dados</h2>

# Introdução

Este notebook demonstra a aplicação de diferentes algoritmos de ordenação de dados considerando cenários de execução com itens de tipo primitivo(`int`) e objetos (`Veiculo`). As funções de apoio a seguir são utilizadas para a execução dos algoritmos abordados.

Para rodar os experimentos contidos neste notebook, é necessário que a célular referente às **Funções de Apoio** sejam executadas. Em seguida, você pode escolher os algoritmos que deseja monitorar o tempo de execução da tarefa.

## Medindo o tempo de execução de algoritmos: A função **timeit**

Biblioteca **timeit**: cria um timer para medir o tempo de execução em segundos de pequenos fragmentos de código na Linguagem Python:

Sintaxe:
```timeit.timeit ( stmt , setup, number)```

Em que:
* `stmt`: instruções a serem executadas pelo `timeit`
* `setup`: instruções de configuração que precisam ser passadas antes do `stmt`. Exemplos: import's
* `number`: é o número de execuções que você gostaria de executar o stmt.

# Preparação
## Funções de Apoio
Rode esta célula para que os experimentos seguintes possam ser realizados
"""

import random # usar randint() e sample()
import sys  # usar o método sizegetof()
from typing import List # utilizar typehint para List[tipo]
import string   # gerar strings aleatórias
import timeit   # computar o tempo de processamento

# classe encapsuladora de dados de um veículo
class Veiculo:
  def __init__(self, chassi, marca, modelo, preco, ano=2022):
    self.chassi = chassi
    self.marca = marca
    self.modelo = modelo
    self.ano = ano
    self.preco = preco

  def __str__(self):
    return f'{self.chassi}, {self.marca}, {self.modelo}, {self.preco}, {self.ano}'

  def __eq__(self, other):
        return self.chassi == other.chassi

  def __gt__(self, other):
        return self.chassi > other.chassi

  def __lt__(self, other):
        return self.chassi < other.chassi

  def __ge__(self, other):
        return self.chassi >= other.chassi

  def __le__(self, other):
        return self.chassi <= other.chassi


# Função que cria uma string aleatória de tamanho "length"
def generateUpperString(length):
    result = ''.join((random.choice(string.ascii_lowercase) for x in range(length))) # executa o loop até o tamanho especificado
    return result

# Função que criar um list com n elementos do tipo inteiro, aleatórios, entre 0 e 9999
def povoamento_inteiros(num_elementos =10)->List[int]:
    lista = random.sample(range(0,9999), num_elementos)
    return lista

# Função que cria um list com n elementos do tipo Veiculo
def povoamento_objetos(num_elementos =10)->List[Veiculo]:
  lista = list()
  for i in range(num_elementos):
    lista.append(Veiculo(random.randint(1,99999),"CODER", generateUpperString(random.randint(1,50)), 62000))
  return lista

# Exibe a lista de veiculos por meio do numero do chassi
def printByChassi( colecao: List[Veiculo], limite = None):
  limite = len(colecao) if limite is None else limite
  limite = len(colecao) if limite > len(colecao) else limite
  print('[ ',end='')
  for i in range(limite):
    print(colecao[i].chassi,end=', ')
  print(' ]')


array_original = povoamento_inteiros(900)
print('Quantidade de bytes do array de inteiros:', sys.getsizeof(array_original))
veiculo = povoamento_objetos(10)
print('Quantidade de bytes do array de objetos:', sys.getsizeof(veiculo))
print()
for d in veiculo:
  print(d, ' tamanho em bytes:', sys.getsizeof(d)) #tamanho de cada objeto interno

# Observe que cada string em Python ocupa 49-80 bytes adicionais de memória, onde armazena informações suplementares,
# como hash, comprimento, comprimento em bytes, tipo de codificação e sinalizadores de string. Cada caractere pode
# ocupar 1, 2 ou 4 bytes, de acordo com o encoding
# https://rushter.com/blog/python-strings-and-memory/#:~:text=1%20byte%20per%20char%20(Latin%2D1%20encoding)

v = veiculo[6]
print("Tamanho de uma referencia para objeto: ",sys.getsizeof(v))
print("chassi: ", sys.getsizeof(v.chassi))
print("marca.: ", sys.getsizeof(v.marca))
print("modelo: ", sys.getsizeof(v.modelo))
print("ano...: ", sys.getsizeof(v.ano))
print("preco.: ", sys.getsizeof(v.preco))
print("------------------------------------")
total = sys.getsizeof(v) + sys.getsizeof(v.chassi) + sys.getsizeof(v.marca) + sys.getsizeof(v.modelo) + sys.getsizeof(v.ano) + sys.getsizeof(v.preco)
print("Total: ", total)
print(sys.getsizeof(""))

"""# Algoritmos de Ordenação"""

def bubble_sort(array):
    for i in range(len(array)-1,0,-1):
        troca = False
        for j in range(0,i):
            if (array[j] > array[j+1] ):
                array[j],array[j+1] = array[j+1],array[j] # Efetua a troca
                troca = True
        if( not troca ): # não houve troca
            return

def bubble_sort_recursivo(array):
    executaBolha(array,len(array))

def executaBolha(array,size):
    troca = False
    for j in range(size-1):
        if (array[j] > array[j+1] ):
            temp = array[j]
            array[j] = array[j+1] # Efetua a troca
            array[j+1] = temp
            troca = True
    if (troca):      # Houve troca
        executaBolha(array,size-1)

def selection_sort(array):
    for i in range(len(array)-1):
        min = i
        for j in range(i+1, len(array)):
            if(array[j] < array[min]):
                min = j
        array[min], array[i] = array[i], array[min] # troca

def insertion_sort(array):
    for i in range(1, len(array)):
        # chave do subarray desordenado
        key = array[i]

        j = i-1
        while j>=0 and key < array[j]:
            array[j+1] = array[j]
            j -= 1

        array[j+1] = key

# Algoritmo Clássico (Hoare & Lomuto)
def partition(array,low,high):
    pivot = array[low] # pivot

    a = low + 1 # indice que sobe de forma crescente
    b = high # indice que desce de forma decrescente

    while(True):
        while( a <= high  and array[a] <= pivot ): # Deslocando o indice para a direita
            a+=1

        while( array[b] > pivot): # Deslocando o indice do final para a esquerda
            b-=1

        if ( a < b ): # Se o indice "a" for menor que "b", realizamos a troca
            array[a],array[b] = array[b],array[a]
            a+=1
            b-=1

        if( a > b): # se a cruzar com b, sai do laço
            break
    # Ja foi encontrado o lugar do pivo. Agora vamos troca-lo com o elemento
    # que se encontra no indice
    array[low] = array[b]
    array[b] = pivot

    return ( b )

# função recursiva que aciona o particionamento e chamadas recursivas das
# subdivisões do array
def quickSortRun(array,low,high):
    if low < high:
        # pi é o índice de particionamento
        pi = partition(array,low,high)

        # Separadamente, os elementos antes e depois e antes da
        # partição são ordenados
        quickSortRun(array, low, pi-1)
        quickSortRun(array, pi+1, high)

def quick_sort(array):
    quickSortRun(array,0,len(array)-1)

def quick_sort_lc(vetor):
    if len(vetor) <= 1: return vetor
    pivo = vetor[0]
    iguais = [x for x in vetor if x == pivo]
    menores = [x for x in vetor if x < pivo]
    maiores = [x for x in vetor if x > pivo]
    return quick_sort_lc(menores) + iguais + quick_sort_lc(maiores)

# Utiliza a mesma função partition() definida na solução recursiva v1

# arr[] --> Array a ser ordenado,
# l  --> indice inicial,
# h  --> indie final
def quickSortRunIter(arr,l,h):
    # criação de uma pilha inicial
    size = h - l + 1
    stack = list()

    # push initial values of l and h to stack
    stack.append(l)
    stack.append(h)

    # Keep popping from stack while is not empty
    while len(stack) > 0:

        # Pop h and l
        h = stack.pop()
        l = stack.pop()

        # Set pivot element at its correct position in
        # sorted array
        p = partition( arr, l, h )

        # If there are elements on left side of pivot,
        # then push left side to stack
        if p-1 > l:
            stack.append(l)
            stack.append(p-1)

        # If there are elements on right side of pivot,
        # then push right side to stack
        if p+1 < h:
            stack.append(p+1)
            stack.append(h)

def quick_sort_iterativo(array):
    quickSortRunIter(array,0,len(array)-1)

def merge_sort(array:List[int]):
    if len(array) > 1:
        mid = len(array) // 2
        left = array[:mid]
        right = array[mid:]

        # Chamada recursiva para cada metade do array
        merge_sort(right)
        merge_sort(left)

        # Aqui é iniciado o processo de merge dos vetores

        # iteradores para percurso das duas metades
        i = 0 # iterador para a metade esquerda
        j = 0 # iterador para a metade direita

        # iterador para o array principal
        k = 0

        # Comparando os elementos da metade da esquerda e da direita
        while i < len(left) and j < len(right):
            if left[i] <= right[j]:
              # O valor da metade esquerda é ordenado
              array[k] = left[i]
              # Avança o iterador da metade esquerda
              i += 1
            else:
                # o valor da metade direita é ordenado
                array[k] = right[j]
                # Avança o iterador da metade direita
                j += 1
            # Avança para o próximo slot do array principal
            k += 1

        # Os valores remanescentes, da metade esquerda, são copiados
        while i < len(left):
            array[k] = left[i]
            i += 1
            k += 1

        # Os valores remanescentes, da metade direita, são copiados
        while j < len(right):
            array[k]=right[j]
            j += 1
            k += 1

"""#**Cenário 1:**
<p>Cada algoritmo recebe um conjunto de dados desordenado de forma aleatória, com 900 elementos. A geração dos dados e execução do algoritmo é realizada 1.000 vezes. Cada execução utiliza um array desordenado <b>diferente</b>. Conteúdo do array: <b>inteiros</b>

## 1. Bubble Sort
"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    bubble_sort(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); bubble_sort(lista)", setup="from __main__ import bubble_sort; from __main__ import povoamento_inteiros", number=1000))

"""## 2. Bubble Sort Recursivo

"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    bubble_sort_recursivo(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); bubble_sort_recursivo(lista)", setup="from __main__ import bubble_sort_recursivo; from __main__ import povoamento_inteiros", number=1000))

"""## 3. Selection Sort

"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    bubble_sort_recursivo(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); selection_sort(lista)", setup="from __main__ import selection_sort; from __main__ import povoamento_inteiros", number=1000))

"""## 4. Insertion Sort"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    bubble_sort_recursivo(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); insertion_sort(lista)", setup="from __main__ import insertion_sort; from __main__ import povoamento_inteiros", number=1000))

"""## 5. Quick Sort Recursivo v1 (versão clássica)"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    quick_sort(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); quick_sort(lista)", setup="from __main__ import quick_sort; from __main__ import povoamento_inteiros", number=1000))

"""## 5. Quicksort Recursivo v2 (list comprehension)"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    quick_sort_lc(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); quick_sort_lc(lista)", setup="from __main__ import quick_sort_lc; from __main__ import povoamento_inteiros", number=1000))

"""##6. Quick Sort Iterativo"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    quick_sort_iterativo(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); quick_sort_iterativo(lista)", setup="from __main__ import quick_sort_iterativo; from __main__ import povoamento_inteiros", number=1000))

"""## 7. Merge Sort"""

if __name__ == '__main__':
    lista = povoamento_inteiros(900)
    print("lista desordenada = ", lista)
    merge_sort(lista)
    print("lista ordenada = ", lista)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista=povoamento_inteiros(900); merge_sort(lista)", setup="from __main__ import merge_sort; from __main__ import povoamento_inteiros", number=1000))

"""##8. Comparação do Tempo de Execução

* Ordenação de uma lista com 900 elementos (1.000 execuções)
* A cada execução, uma nova lista é gerada no timeit.
* Ordenação de array de inteiros
* Os algoritmos *não* estão ordenando o mesmo conjunto de dados


| Algoritmo                              | Tempo de execução (1000x) |
|---------------------------------------|------|
| Bubble Sort                            | 77.7s |
| Bubble Sort Recursivo                  | 83.8s |
| Selection Sort                         | 38.3s |
| Insertion Sort                         | 38.1s |
| **Quicksort v1**    | **2.7s** |
| **Quicksort v2**    | **4.7s** |
| **Quicksort Iterativo**    | **2.7s** |
| **Merge Sort**    | **4.9s** |

#**Cenário 2:**
<p>Impondo o mesmo conjunto de dados do tipo <b>inteiro</b> criado randomicamente, com 900 elementos, a <b>todos os algoritmos de ordenação</b>. Isto significa que o ambiente é mais justo, haja vista que todos os algoritmos recebem a mesma entrada de dados para ordenar.
"""

array = povoamento_inteiros(900)

    print("Bubble Sort Iterativo:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; bubble_sort(lista)", setup="from __main__ import bubble_sort; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    bubble_sort(lista)
    print("lista ordenada = ", lista)
    print()

    print("Bubble Sort Recursivo:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; bubble_sort_recursivo(lista)", setup="from __main__ import bubble_sort_recursivo; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    bubble_sort_recursivo(lista)
    print("lista ordenada = ", lista)
    print()

    print("Selection Sort:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; selection_sort(lista)", setup="from __main__ import selection_sort; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    selection_sort(lista)
    print("lista ordenada = ", lista)
    print()

    print("Insertion Sort:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; insertion_sort(lista)", setup="from __main__ import insertion_sort; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    quick_sort(lista)
    print("lista ordenada = ", lista)
    print()

    print("Quick Sort:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; quick_sort(lista)", setup="from __main__ import quick_sort; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    quick_sort(lista)
    print("lista ordenada = ", lista)
    print()

    print("Quick Sort (list comprehension):")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; quick_sort_lc(lista)", setup="from __main__ import quick_sort_lc; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    quick_sort_lc(lista)
    print("lista ordenada = ", lista)
    print()

    print("Merge Sort:")
    print("--------------------------------------------")
    print("lista desordenada = ", array)
    print("Timeit: ", timeit.timeit("lista=array[:]; merge_sort(lista)", setup="from __main__ import merge_sort; from __main__ import povoamento_inteiros; from __main__ import array", number=1000))
    lista = array[:]
    merge_sort(lista)
    print("lista ordenada = ", lista)
    print()

"""##9. Tabela Comparativa do Tempo de Execução

| Algoritmo                              | Tempo de execução (1000x) |
|---------------------------------------|------|
| Bubble Sort Iterativo                           | 69.28s |
| Bubble Sort Recursivo                  | 74.7s |
| Selection Sort                         | 31.85s |
| Insertion Sort                         | 32.37s |
| **Quicksort**    | **1.34s** |
| **Quicksort list comprehension**    | **1.92s** |
| **Merge Sort**    | **2.43s** |

#**Cenário 3:**
<p>Utiliza o mesmo conjunto de dados do tipo <b>Veiculo</b> criado randomicamente, com 900 elementos, a <b>todos os algoritmos de ordenação</b>. Isto significa que o ambiente é mais justo, haja vista que todos os algoritmos recebem a mesma entrada de dados para ordenar. Exercuta o algoritmo 1.000 vezes.
"""

array_veiculos = povoamento_objetos(900)

"""## Bubble Sort Iterativo"""

if __name__ == '__main__':
    lista = array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    bubble_sort(lista)
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista = array_veiculos[:]; bubble_sort(lista)", setup="from __main__ import bubble_sort; from __main__ import array_veiculos", number=1000))

"""## Bubble Sort Recursivo"""

if __name__ == '__main__':
    lista = array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    bubble_sort_recursivo(lista)
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista = array_veiculos[:]; bubble_sort_recursivo(lista)", setup="from __main__ import bubble_sort_recursivo; from __main__ import array_veiculos", number=1000))

"""## Selection Sort"""

if __name__ == '__main__':
    lista = array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    selection_sort(lista)
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
    print(timeit.timeit("lista = array_veiculos[:]; selection_sort(lista)", setup="from __main__ import selection_sort; from __main__ import array_veiculos", number=1000))

"""## Insertion Sort"""

if __name__ == '__main__':
  lista = array_veiculos[:]
  print("lista desordenada = ", end='')
  printByChassi(lista, 10)
  insertion_sort(lista)
  print("lista ordenada = ", end='')
  printByChassi(lista,10)

  print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
  print(timeit.timeit("lista = array_veiculos[:]; insertion_sort(lista)", setup="from __main__ import insertion_sort; from __main__ import array_veiculos", number=1000))

"""## Quick Sort Clássico"""

if __name__ == '__main__':
  lista = array_veiculos[:]
  print("lista desordenada = ", end='')
  printByChassi(lista, 10)
  quick_sort(lista)
  print("lista ordenada = ", end='')
  printByChassi(lista,10)

  print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
  print(timeit.timeit("lista = array_veiculos[:]; quick_sort(lista)", setup="from __main__ import quick_sort; from __main__ import array_veiculos", number=1000))

"""## Quick Sort (List Comprehension)"""

if __name__ == '__main__':
  lista = array_veiculos[:]
  print("lista desordenada = ", end='')
  printByChassi(lista, 10)
  quick_sort_lc(lista)
  print("lista ordenada = ", end='')
  printByChassi(lista,10)

  print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
  print(timeit.timeit("lista = array_veiculos[:]; quick_sort_lc(lista)", setup="from __main__ import quick_sort_lc; from __main__ import array_veiculos", number=1000))

"""## Merge Sort"""

if __name__ == '__main__':
  lista = array_veiculos[:]
  print("lista desordenada = ", end='')
  printByChassi(lista, 10)
  merge_sort(lista)
  print("lista ordenada = ", end='')
  printByChassi(lista,10)

  print("Tempo de execução: 1000 execuções de ordenação em um array de 900 elementos")
  print(timeit.timeit("lista = array_veiculos[:]; merge_sort(lista)", setup="from __main__ import merge_sort; from __main__ import array_veiculos", number=1000))

"""##Comparativo e desempenho dos algoritmos

As medições ilustradas a seguir foram executadas em um computador pessoal, fora do ambiente Google Colab.

**Motivo:** o Google Colab ficava instável quando o cenário era instanciado. Percebeu-se, localmente, que o algoritmo tinha uma tempo de execução menor em relação ao tempo alcançado no ambiente Google Colab.

| Algoritmo                              | Tempo de execução (1000x) |
|---------------------------------------|------|
| Bubble Sort                            | 115.86 s |
| Bubble Sort Recursivo                  | 115.12 s |
| Selection Sort                         | 78.35 s |
| Insertion Sort                         | 59.33 s |
| **Quicksort**    | **3.37s** |
| **Quicksort lc**    | **5.77s** |
| **Merge Sort**    | **3.32s** |

#**Cenário 4:**
<p>Adotando o mesmo conjunto de dados do tipo <b>Veiculo</b> criado a <b>todos os algoritmos de ordenação</b>, porém, com 50.000 elementos.
"""

import time
size = 50000
big_array_veiculos = povoamento_objetos(size)
print('len(big_array_veiculos) =', len(big_array_veiculos))

"""##Bubble Sort Iterativo"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    bubble_sort(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##Bubble Sort Recursivo"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    bubble_sort_recursivo(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""## Selection Sort"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    selection_sort(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print("Tempo de execução: array 50.000 elementos:", final_time)
    #print(timeit.timeit("lista = big_array_veiculos[:]; selection_sort(lista)", setup="from __main__ import selection_sort; from __main__ import big_array_veiculos", number=1000))

"""##Insertion Sort"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    insertion_sort(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##Quick Sort Clássico"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    quick_sort(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##Quick Sort (list comprehension)"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    lista = quick_sort_lc(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##Quick Sort Iterativo"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    quick_sort_iterativo(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##Merge Sort"""

if __name__ == '__main__':
    start_time = time.time()
    lista = big_array_veiculos[:]
    print("lista desordenada = ", end='')
    printByChassi(lista,10)
    merge_sort(lista)
    final_time = time.time() - start_time
    print("lista ordenada = ", end='')
    printByChassi(lista,10)
    print(f"Tempo de execução (array {size} elementos: {final_time}")

"""##9. Tabela Comparativa do Tempo de Execução

População: 50.000 elementos

| Algoritmo                              | 1x | 1000x
|---------------------------------------|------|------
| Bubble Sort Iterativo                  | 701.75s | ?
| Bubble Sort Recursivo                  | **RecursionError** | ?
| Selection Sort                         | 501.38s | ?
| Insertion Sort                         | 393.77s | ?
| **Quicksort**    | **0.39s** | ?
| **Quicksort Iterativo**    | **0.35s** | ?
| **Quicksort list comprehension**    | **1.03s** | ?
| **Merge Sort**    | **0.37s** | ?

#3. Gráfico: Complexidade Big-O (performance)
| Algoritmo                              | Complexidade média |
|---------------------------------------|------|
| Bubble Sort                            | O(n2) |
| Bubble Sort Recursivo                  | O(n2) |
| Selection Sort                         | O(n2) |
| Insertion Sort                         | O(n2) |
| **Quicksort**    | O(n.log(n)) |
| **Merge Sort**    | O(n.log(n)) |

#4. Técnicas de Busca

##Algoritmos
"""

from typing import List

def busca_sequencial(chave: any, array: List[any])->int:
  nIter = 0
  for i in range(len(array)):
    nIter+=1
    if array[i] == chave:
      return i, nIter
  return -1,nIter

def busca_sequencial_recursiva(chave: any, array: List[any], i: int = 0)->int:
  if i >= len(array) or array[i] > chave:
    return -1,i

  if array[i] == chave:
      return i
  return busca_sequencial_recursiva(chave, array, i+1)

def busca_sequencial_ordenada(chave: any, array: List[any])->int:
  nIter = 0
  for i in range(len(array)):
    nIter+=1
    if array[i] == chave:
      return i,nIter
    if array[i] > chave:
      return -1,nIter
  return -1,nIter

def busca_binaria(chave: int, array: List[any]) -> int:
  primeiro: int = 0
  ultimo: int = len(array)-1

  nIter = 0
  while primeiro <= ultimo:
    meio = (primeiro + ultimo) // 2
    nIter += 1
    if array[meio] == chave:
      ## Item encontrado
      return meio,nIter

    if chave < array[meio]:
      ultimo = meio - 1
    else:
      primeiro = meio + 1

  return -1,nIter ## item não encontrado

def busca_binaria_recursiva(chave: int, array: List[any], primeiro=0, ultimo=None) -> int:

  if not ultimo:
    ultimo = len(array)-1

  meio = (primeiro + ultimo) // 2

  if array[meio] == chave:
    return meio

  if meio == 0 or primeiro == ultimo:
    return -1

  if chave < array[meio]:
    return busca_binaria_recursiva(chave, array, primeiro, meio)
  else:
    return busca_binaria_recursiva(chave, array, meio+1, ultimo)

size = 9000
lista_original = povoamento_inteiros(size)
lista_ordenada = lista_original[:]
quick_sort(lista_ordenada)
print(lista_ordenada)
print('Max:',max(lista_ordenada))

"""##Simulações de Busca"""

chave = random.choice(lista_original)
print('Chave gerada...:', chave)
print('Indice da chave:', lista_ordenada.index(chave))
i,it = busca_sequencial(chave, lista_original)
print(f'Busca Sequencial (desordenado): chave = {chave}, i= {i:5d}, Numero de Iteracoes = {it}')
i,it = busca_sequencial_ordenada(chave, lista_ordenada)
print(f'Busca Sequencial (ordenada)...: chave = {chave}, i= {i:5d}, Numero de Iteracoes = {it}')
i,it = busca_binaria(chave, lista_ordenada)
print(f'Busca Binária (ordenada)......: chave = {chave}, i= {i:5d}, Numero de Iteracoes = {it}')

chave = 999999
print('-------------- Chave Inexistente maior do que o max  -------------------------')
i,it = busca_sequencial(chave, lista_original)
print(f'Busca Sequencial (desordenado): chave = {chave}, i= {i}, Numero de Iteracoes = {it}')
i,it = busca_sequencial_ordenada(chave, lista_ordenada)
print(f'Busca Sequencial (ordenada)...: chave = {chave}, i= {i}, Numero de Iteracoes = {it}')
i,it = busca_binaria(chave, lista_ordenada)
print(f'Busca Binária (ordenada)......: chave = {chave}, i= {i}, Numero de Iteracoes = {it}')

chave = 6
print('-------------- Chave Inexistente maior do que o max  -------------------------')
i,it = busca_sequencial(chave, lista_original)
print(f'Busca Sequencial (desordenado): chave = {chave}, i= {i}, Numero de Iteracoes = {it}')
i,it = busca_sequencial_ordenada(chave, lista_ordenada)
print(f'Busca Sequencial (ordenada)...: chave = {chave}, i= {i}, Numero de Iteracoes = {it}')
i,it = busca_binaria(chave, lista_ordenada)
print(f'Busca Binária (ordenada)......: chave = {chave}, i= {i}, Numero de Iteracoes = {it}')